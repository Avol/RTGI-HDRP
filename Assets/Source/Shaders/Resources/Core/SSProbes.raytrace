#include "../Common.cginc"
#include "../Octahedron.cginc"

//--------------------------------------------------------------------------------------------------
// Included headers
//--------------------------------------------------------------------------------------------------

// Don't want contact shadows
#define LIGHT_EVALUATION_NO_CONTACT_SHADOWS // To define before LightEvaluation.hlsl
// #define LIGHT_EVALUATION_NO_HEIGHT_FOG

#ifndef LIGHTLOOP_DISABLE_TILE_AND_CLUSTER
    #define USE_BIG_TILE_LIGHTLIST
#endif

#define PREFER_HALF             0
#define GROUP_SIZE_1D           8
#define SHADOW_USE_DEPTH_BIAS   0 // Too expensive, not particularly effective
#define SHADOW_ULTRA_LOW          // Different options are too expensive.
#define AREA_SHADOW_LOW           // Different options are too expensive.
#define SHADOW_AUTO_FLIP_NORMAL 0 // No normal information, so no need to flip
#define SHADOW_VIEW_BIAS        1 // Prevents light leaking through thin geometry. Not as good as normal bias at grazing angles, but cheaper and independent from the geometry.
#define USE_DEPTH_BUFFER        1 // Accounts for opaque geometry along the camera ray
#define SAMPLE_PROBE_VOLUMES    1 && (defined(PROBE_VOLUMES_L1) || defined(PROBE_VOLUMES_L2))

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/GeometricTools.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Filtering.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/VolumeRendering.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/EntityLighting.hlsl"

// We need to include this "for reasons"...
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Builtin/BuiltinData.hlsl"

#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl"

#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Sky/PhysicallyBasedSky/PhysicallyBasedSkyCommon.hlsl"

#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightEvaluation.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/NormalBuffer.hlsl"


RaytracingAccelerationStructure _RaytracingAccelerationStructure;

#pragma max_recursion_depth 1

#define SHADER_TARGET 50

RWTexture2D<float4> _SSProbes;

uniform				int			_Frame;
uniform				int			_RayCount;

uniform				int			_ProbeSize;
uniform				int			_Upscale;
uniform				float		_RayConeAngle;


int traceShadow(float3 worldPos)
{
	DirectionalLightData light = _DirectionalLightDatas[_DirectionalShadowIndex];

	// Create the ray descriptor for this pixel
	RayDesc rayDescriptor;
	rayDescriptor.TMin			= 0;
	rayDescriptor.TMax			= 100;
	rayDescriptor.Origin		= worldPos;
	rayDescriptor.Direction		= -light.forward;

	// Create and init the RayIntersection structure for this
	RayPayload	rayIntersection;
	rayIntersection.color				= 0;
	rayIntersection.distance			= -1;

	TraceRay(_RaytracingAccelerationStructure, RAY_FLAG_CULL_BACK_FACING_TRIANGLES, RAYTRACING_OPAQUE_FLAG, 0, 1, 0, rayDescriptor, rayIntersection);


	return rayIntersection.distance != -1 ? 0 : 1;
}

// TODO: if point outside of camera view, or even better outside of shadow view, do traced shadow.
// tracing is probably not needed for non directional lights.
float3 LightLoop(float3 positionWS)
{
	LightLoopContext context;
	context.shadowContext    = InitShadowContext();
    context.shadowValue      = 1;
    context.sampleReflection = 0;
    context.splineVisibility = -1;

	float3 color = 0;

	if (_DirectionalShadowIndex >= 0)
    {
		BuiltinData unused; // Unused for now, so define once
		ZERO_INITIALIZE(BuiltinData, unused);

		DirectionalLightData light = _DirectionalLightDatas[_DirectionalShadowIndex];

		float3 L = -light.forward;

		PositionInputs posInput;
		posInput.positionWS = positionWS - _WorldSpaceCameraPos;
		posInput.positionSS = 0;
		float3 normalWS		= 0;

		context.shadowValue = traceShadow(positionWS); /*GetDirectionalShadowAttenuation(	context.shadowContext,
																posInput.positionSS, posInput.positionWS, normalWS,
																light.shadowIndex, L);*/


		SHADOW_TYPE shadow = EvaluateShadow_Directional(context, posInput, light, unused, normalWS);
		color += ComputeShadowColor(shadow, light.shadowTint, light.penumbraTint);
	}

	return color;
}


float4 trace(uint seed, float3 worldPos, float3 normal, float3 octaRay)
{
	const uint rayCount = _RayCount;


	float4 radiance = 0;
	int countRays = 0;
	for (int i = 0; i < _RayCount; i++)
	{
		float invCone = 1.0 - _RayConeAngle;

		float3 jitteredOctaRay = normalize(octaRay * invCone + getCosHemisphereSample(seed, octaRay) * _RayConeAngle);

		if (dot(normal, jitteredOctaRay) <= 0)
			return 0;

		// Create the ray descriptor for this pixel
		RayDesc rayDescriptor;
		rayDescriptor.TMin			= 0;
		rayDescriptor.TMax			= 100;
		rayDescriptor.Direction		= jitteredOctaRay;
		rayDescriptor.Origin		= worldPos + normal * 0.005;// + jitteredOctaRay * 0.01;

		// Create and init the RayIntersection structure for this
		RayPayload	rayIntersection;
		rayIntersection.color				= 0;
		rayIntersection.distance			= 0;

		TraceRay(_RaytracingAccelerationStructure, RAY_FLAG_CULL_BACK_FACING_TRIANGLES, RAYTRACING_OPAQUE_FLAG, 0, 1, 0, rayDescriptor, rayIntersection);

		float3 hitPosition	= worldPos + jitteredOctaRay * (rayIntersection.distance - 0.01);

		float3 lightLoop	= LightLoop(hitPosition);

		radiance += float4(rayIntersection.color * lightLoop, rayIntersection.distance / 100);
		countRays++;
	}

	if (countRays == 0)
		return 0;
	 
	return radiance / countRays;
}


[shader("raygeneration")]
void MyRaygenShader()
{
	// current pixel
	uint2	dispatchIdx		= DispatchRaysIndex().xy;
	float2	resolution		= DispatchRaysDimensions().xy;


	uint	seed				= initRand(dispatchIdx.x, dispatchIdx.y) + initRand(_Frame, _Frame);

	float2	jitter			= float2(	random(dispatchIdx.xy / resolution + _Frame / 128.0),
										random(dispatchIdx.yx / resolution + _Frame / 128.0) );
	uint2	jitterUint2			= min(_ProbeSize - 1, floor(jitter * _ProbeSize));

	uint2	jiterredDispatch	= (dispatchIdx.xy - dispatchIdx.xy % _ProbeSize) + jitterUint2 / _Upscale;
	float2	screenUV			= jiterredDispatch / resolution;

	float	depth				= LoadCameraDepth(jiterredDispatch);
	
	// position
	PositionInputs posInput		= GetPositionInput(jiterredDispatch, _ScreenSize.zw, depth, UNITY_MATRIX_I_VP, UNITY_MATRIX_V);
	float3	worldPosition		= posInput.positionWS + _WorldSpaceCameraPos;

	// normal
	NormalData normalData0;
	DecodeFromNormalBuffer(jiterredDispatch, normalData0);
	float3	normal				= normalData0.normalWS;


	// calculate octahedral ray direction.
	float2	octaUV		= dispatchIdx.xy % _ProbeSize;
	float3	octaRay		= UVtoOctahedron((octaUV + 0.5) / _ProbeSize);

	_SSProbes[dispatchIdx] = trace(seed, worldPosition, normal, octaRay);
}

[shader("miss")]
void MissShader(inout RayPayload rayIntersection : SV_RayPayload)
{ 
	rayIntersection.color			= float3(0, 0, 0);
	rayIntersection.distance		= -1;
}